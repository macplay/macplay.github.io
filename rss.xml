<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MacPlay</title><link>https://macplay.github.io/</link><description>Share something interesting about byte ocean</description><atom:link href="https://macplay.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><copyright>Contents © 2020 &lt;a href="mailto:ashfinal@sina.cn"&gt;ashfinal&lt;/a&gt; </copyright><lastBuildDate>Wed, 26 Aug 2020 08:50:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>FFmpeg Filtering Guide</title><link>https://macplay.github.io/posts/ffmpeg-filtering-guide/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/ffmpeg_datascope.png"&gt;&lt;img alt="ffmpeg_datascope" src="https://macplay.github.io/images/ffmpeg_datascope.thumbnail.png"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title"&gt;文档目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/ffmpeg-filtering-guide/#ffmpeg-filtering" id="id12"&gt;FFmpeg Filtering 介绍&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/ffmpeg-filtering-guide/#testsrc" id="id13"&gt;testsrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/ffmpeg-filtering-guide/#ffmpeg-ffplay-filters" id="id14"&gt;在 ffmpeg/ffplay 中使用 filters&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/ffmpeg-filtering-guide/#mpv-player" id="id15"&gt;mpv player&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/ffmpeg-filtering-guide/#mmate" id="id16"&gt;mmate&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ffmpeg-filtering"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://macplay.github.io/posts/ffmpeg-filtering-guide/#id12"&gt;FFmpeg Filtering 介绍&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Filtering in FFmpeg is enabled through the libavfilter library.&lt;/p&gt;
&lt;p&gt;In libavfilter, a filter can have multiple inputs and multiple outputs. To illustrate the sorts of things that are possible, we consider the following filtergraph:&lt;/p&gt;
&lt;pre class="literal-block"&gt;                [main]
input --&amp;gt; split ---------------------&amp;gt; overlay --&amp;gt; output
            |                             ^
            |[tmp]                  [flip]|
            +-----&amp;gt; crop --&amp;gt; vflip -------+&lt;/pre&gt;
&lt;p&gt;This filtergraph splits the input stream in two streams, then sends one stream through the crop filter and the vflip filter, before merging it back with the other stream by overlaying it on top. You can use the following command to achieve this:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/ffmpeg-filtering-guide/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>ffmpeg</category><guid>https://macplay.github.io/posts/ffmpeg-filtering-guide/</guid><pubDate>Mon, 24 Feb 2020 12:50:03 GMT</pubDate></item><item><title>【译】强大的文件差异比较</title><link>https://macplay.github.io/posts/the-power-of-diff/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;很多人在终端模式下使用 vimdiff 来查看和处理 diff 差异，此外，还有很多专业的文件差异比较 diff 工具。然而，vimdiff 于我来说已然足够。&lt;/p&gt;
&lt;div class="section" id="diff"&gt;
&lt;h2&gt;低效的外部 diff&lt;/h2&gt;
&lt;p&gt;严格来说，Vim 的 diff 模式也有不足。基本上，它需要写入临时文件，切到 shell 运行 diff 命令，再将结果解析出来。你可以想象，这个过程会很慢，一点也不高效。&lt;/p&gt;
&lt;p&gt;除此之外，它还需要一个二进制 diff 程序以创建 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Diff#Edit_script"&gt;ed 风格的 diff&lt;/a&gt; 。所以，想要使用 git-diff 命令（被认为是最好的 diff 库，可选择不同的 diff 算法）也是不行的。这导致某些 vimscript &lt;a class="reference external" href="https://github.com/chrisbra/vim-diff-enhanced"&gt;插件&lt;/a&gt; 的诞生，该插件在内部将 unified diff 转换为 ed diff。当然，这将增加额外的性能损失。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/the-power-of-diff/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>asciinema</category><category>diff</category><category>vim</category><guid>https://macplay.github.io/posts/the-power-of-diff/</guid><pubDate>Thu, 14 Nov 2019 14:28:48 GMT</pubDate></item><item><title>【译】Atom 新的并发友好型 buffer 实现</title><link>https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;Atom 的一些功能依赖于缓冲区（buffer）内容基础上的运算（可能会花费很长时间），但是直到最近，还只能从运行在主线程上的 JavaScript 访问缓冲区的文本。这使得无法在所有情况下保证 Atom 的响应能力，尤其是在编辑较大文件时。&lt;/p&gt;
&lt;p&gt;这种情况随着 Atom 1.19 的发布而有所改变，该版本通过使用 C++ 实现的文本存储极大地提高了并行处理能力。这项新设计为性能和可伸缩性提供了诸多好处，其中主要优点之一是 worker 线程可以读取之前缓冲区的快照（snapshot），而不会阻塞主线程上的写入。在这篇文章中，我们将深入介绍 Atom 的文本存储新方法，然后探讨由此带来的首批优化。&lt;/p&gt;
&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title"&gt;文档目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#layering" id="id12"&gt;分层（layering）的变动&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#patch" id="id13"&gt;Patch 的数据结构&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id2" id="id14"&gt;存在的问题&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id3" id="id15"&gt;原生的解决方案&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#splay-trees" id="id16"&gt;Splay trees&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id4" id="id17"&gt;为我们的用例增强 splay tree&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id6" id="id18"&gt;一些初始优化&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#unsaved-changes" id="id19"&gt;高效备份 unsaved changes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id8" id="id20"&gt;异步保存&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id9" id="id21"&gt;自动补全时在后台进行子序列匹配&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/#id11" id="id22"&gt;未来回报&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>atom</category><category>data structure</category><guid>https://macplay.github.io/posts/atoms-new-concurrency-friendly-buffer-implementation/</guid><pubDate>Sat, 26 Oct 2019 06:41:03 GMT</pubDate></item><item><title>【译】重新实现 Text Buffer</title><link>https://macplay.github.io/posts/text-buffer-reimplementation/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;Visual Studio Code 1.21 发行版包含一个全新的 text buffer（文本缓冲区）实现，无论在速度还是在内存使用方面，该实现都更加出色。在本文中，我想讲一下我们是如何选择/设计数据结构和算法以实现这些提升的。&lt;/p&gt;
&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title"&gt;文档目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#text-buffer" id="id19"&gt;之前的 text buffer 数据结构&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id3" id="id20"&gt;寻找新的 text buffer 实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id4" id="id21"&gt;使用 piece table 来避免过多的元数据&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id5" id="id22"&gt;使用缓存加速行查找&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id6" id="id23"&gt;避免字符串合并陷阱&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id7" id="id24"&gt;使用平衡二叉树加速行查找&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id9" id="id25"&gt;减少对象分配&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#piece-tree" id="id26"&gt;Piece Tree&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id10" id="id27"&gt;准备工作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id11" id="id28"&gt;1. 内存使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id12" id="id29"&gt;2. 文件打开时间&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id13" id="id30"&gt;3. 编辑&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id14" id="id31"&gt;4. 读取&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id15" id="id32"&gt;结论与陷阱&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id16" id="id33"&gt;得到的教训&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id17" id="id34"&gt;为何不用原生代码？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/posts/text-buffer-reimplementation/#id18" id="id35"&gt;未来的工作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/text-buffer-reimplementation/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>benchmark</category><category>data structure</category><category>vscode</category><guid>https://macplay.github.io/posts/text-buffer-reimplementation/</guid><pubDate>Thu, 24 Oct 2019 09:35:29 GMT</pubDate></item><item><title>在浏览器中运行 Vim 编辑器</title><link>https://macplay.github.io/posts/run-vim-editor-on-browsers/</link><dc:creator>ashfinal</dc:creator><description>&lt;figure&gt;&lt;img src="https://macplay.github.io/images/chrome_vim_wasm.thumbnail.png"&gt;&lt;/figure&gt; &lt;div&gt;&lt;p&gt;有人将 Vim 编辑器移植到了 WebAssembly (Wasm) 格式： &lt;a class="reference external" href="https://github.com/rhysd/vim.wasm"&gt;vim.wasm: Vim Ported to WebAssembly&lt;/a&gt; 。 &lt;a class="reference external" href="https://webassembly.org/"&gt;Wasm&lt;/a&gt; 是一种底层的二进制指令格式，理论上能实现接近 C/C++/Rust 等编译性语言的执行速度，目前已经在主流浏览器 Chrome/Safari/Firefox/Edge 中得到支持。所以现在，你可以在浏览器上体验原汁原味的 Vim 了！&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="vim.wasm on chrome" src="https://macplay.github.io/images/chrome_vim_wasm.png"&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/run-vim-editor-on-browsers/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>vim</category><guid>https://macplay.github.io/posts/run-vim-editor-on-browsers/</guid><pubDate>Wed, 23 Oct 2019 13:29:00 GMT</pubDate></item><item><title>Vim Cheatsheet</title><link>https://macplay.github.io/posts/vim-cheatsheet-2/</link><dc:creator>ashfinal</dc:creator><description>&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/vim_cheatsheet.png"&gt;&lt;img alt="vim cheatsheet" src="https://macplay.github.io/images/vim_cheatsheet.thumbnail.png"&gt;&lt;/a&gt;
&lt;p class="caption"&gt;&lt;em&gt;via&lt;/em&gt; &lt;a class="reference external" href="https://github.com/mhinz/vim-galore"&gt;vim-galore&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description><category>vim</category><guid>https://macplay.github.io/posts/vim-cheatsheet-2/</guid><pubDate>Sat, 19 Oct 2019 10:48:45 GMT</pubDate></item><item><title>Writing a plugin that loads quickly</title><link>https://macplay.github.io/posts/writing-a-plugin-that-loads-quickly/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/lazy_loading.jpg"&gt;&lt;img alt="lazy loading" src="https://macplay.github.io/images/lazy_loading.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;A plugin may grow and become quite long. The startup delay may become noticeable, while you hardly ever use the plugin. Then it's time for a quickload plugin.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/writing-a-plugin-that-loads-quickly/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://macplay.github.io/posts/writing-a-plugin-that-loads-quickly/</guid><pubDate>Fri, 18 Oct 2019 06:11:04 GMT</pubDate></item><item><title>使用 targets.vim 改进和扩展文本对象</title><link>https://macplay.github.io/posts/improve-and-extend-your-text-objects-with-targetsvim/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;欢迎回到 &lt;a class="reference external" href="https://www.barbarianmeetscoding.com/blog/categories/exploring-vim-plugins"&gt;探索 Vim 插件系列&lt;/a&gt; ！在本系列中，你将学习如何发现很棒的 Vim 插件以及如何掌握它们，从而每天提高工作效率。而今天，轮到我的最爱之一了： &lt;a class="reference external" href="https://github.com/wellle/targets.vim"&gt;targets.vim&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="become 1 percent better" src="https://macplay.github.io/images/become-1-percent-better.jpg"&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/improve-and-extend-your-text-objects-with-targetsvim/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>translation</category><category>vim</category><guid>https://macplay.github.io/posts/improve-and-extend-your-text-objects-with-targetsvim/</guid><pubDate>Fri, 11 Oct 2019 09:05:40 GMT</pubDate></item><item><title>最能提升效率的 Vim 快捷键是什么？</title><link>https://macplay.github.io/posts/what-is-your-most-productive-shortcut-with-vim/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/vim-keyboard-cover-macbook.jpg"&gt;&lt;img alt="/images/vim-keyboard-cover-macbook.thumbnail.jpg" src="https://macplay.github.io/images/vim-keyboard-cover-macbook.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.vim.org"&gt;Vim&lt;/a&gt;  编辑器的优势和劣势，我已经了解了不少。作为开发者，使用 Vim 要比其它编辑器要快一些，看起来确是如此。然而，我正在使用 Vim 做一些基础编辑，却时常感到效率慢了 10 倍不止。&lt;/p&gt;
&lt;p&gt;当谈及编辑速度时（你应该更多地关注于此），我们把重点放在两个方面：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;交替地使用左右手，是操作键盘 &lt;strong&gt;最快&lt;/strong&gt; 的方式；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽可能不碰鼠标，是追求极致速度的唯二法门。移动手腕，抓取鼠标，移动鼠标，手指返回键盘……需要花费极长时间（更别说，通常你不得不低头盯着键盘，确保手指放到了正确的位置）。，&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我有以下两个例子，来说明使用 Vim 为何没有体验到效率提升。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/what-is-your-most-productive-shortcut-with-vim/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>linux</category><category>vim</category><guid>https://macplay.github.io/posts/what-is-your-most-productive-shortcut-with-vim/</guid><pubDate>Sun, 29 Sep 2019 00:50:23 GMT</pubDate></item><item><title>Oni 0.32 版本释出</title><link>https://macplay.github.io/posts/oni-032-ban-ben-shi-chu/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;!-- vim:set et sw=4 ts=4 ft=rst: --&gt;
&lt;!-- This file interpreters the title of URL in links.ref --&gt;
&lt;!-- vim:set et sw=4 ts=4 ft=rst: --&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="/images/oni_release.png" src="https://macplay.github.io/images/oni_release.png"&gt;
&lt;/div&gt;
&lt;div class="admonition attention"&gt;
&lt;p class="admonition-title"&gt;注意&lt;/p&gt;
&lt;p&gt;Since they've moved to oni2, that changed lots of things, I'm gonna flag this post as obsolete. DON'T READ!&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;本来对这次版本更新还有些不以为然：为何不把精力放在完善 &lt;a class="reference external" href="https://langserver.org/"&gt;Language Server Protocol&lt;/a&gt; 支持，而跑去写什么新手教程呢？直到今天尝试了下教程，又看了文字版更新内容，才明白过来：Oni 编辑器正朝着我期待的方向前进！&lt;/p&gt;
&lt;p&gt;来看看本次更新的两个重要功能：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/posts/oni-032-ban-ben-shi-chu/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>onivim</category><category>vim</category><category>vimrc</category><guid>https://macplay.github.io/posts/oni-032-ban-ben-shi-chu/</guid><pubDate>Sat, 14 Apr 2018 14:55:50 GMT</pubDate></item></channel></rss>