<!DOCTYPE html>
<html lang="zh_cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Nikola (getnikola.com)">
<title>【译】重新实现 Text Buffer - MacPlay</title>
<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="mask-icon" href="../../safari-pinned-tab.svg" color="#5bbad5">
<link href="../../assets/css/semantic.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/jquery.fancybox.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="canonical" href="https://macplay.github.io/posts/text-buffer-reimplementation/">
<meta name="author" content="ashfinal">
<link rel="alternate" hreflang="en" href="../../en/posts/text-buffer-reimplementation/">
<link rel="stylesheet" type="text/css" href="../../assets/css/gitalk.css">
<link rel="stylesheet" href="../../assets/css/katex.min.css">
</head>
<body>
        <div class="ui grid">
            <div class="computer only three wide column no-print">
                <div id="left-side">
                </div>
            </div>
            <div class="ten wide computer sixteen wide tablet sixteen wide mobile column">
                        <div class="ui inline cookie nag no-print">
            <span class="title">从现在开始，支持中英双语及博文精选 O(∩_∩)O~~</span>
            <i class="close icon"></i>
        </div>
    <header id="header" class="no-print"><div class="ui grid">
        <div class="computer only tablet only sixteen wide column">
            <div class="ui large secondary stackable menu">
                <a class="header item brand-logo" href="https://macplay.github.io/">
                    MacPlay
                </a>
                        <a class="item" href="../../">Posts</a>
                        <a class="item" href="../../listings/">Code</a>
                        <a class="item" href="../../galleries/">Gallery</a>
                        <a class="item" href="../../categories/">Tags</a>
                        <a class="item" href="../../archive.html">Archive</a>
                <div class="right menu">
                    <a class="item" href="../../rss.xml"><i class="rss icon"></i>RSS</a>
                </div>
            </div>
        </div>
        <div class="mobile only sixteen wide column">
            <div class="ui fluid accordion vertical menu">
                <div class="item">
                    <a class="title">MacPlay</a>
                    <div class="content">
                                <a class="item" href="../../">Posts</a>
                                <a class="item" href="../../listings/">Code</a>
                                <a class="item" href="../../galleries/">Gallery</a>
                                <a class="item" href="../../categories/">Tags</a>
                                <a class="item" href="../../archive.html">Archive</a>
                        <a class="item" href="../../rss.xml"><i class="rss icon"></i>RSS</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    </header><main id="main"><div id="main-content">
<div class="postpage post-text page-body" itemscope="itemscope" itemtype="http://schema.org/Article">
            <h1 class="post-title" itemprop="headline">
        <a href=".">【译】重新实现 Text Buffer</a>
    </h1>

    <div class="ui large horizontal link list post-meta">
        <span class="item">By
            <a href="../../authors/ashfinal/">ashfinal</a>
        </span>
            <span class="item">
                <a href="https://github.com/macplay/macplay.github.io/edit/src/posts/text-buffer-reimplementation.rst" target="_blank" title="Edit on GitHub">Edit</a>
            </span>
        <span class="item">
            <time datetime="2019-10-24T17:35:29+08:00">
            2019-10-24 17:35
            </time></span>
            <span class="item">
                    <a href="../../categories/benchmark/">benchmark</a>
                    <a href="../../categories/data-structure/">data structure</a>
                    <a href="../../categories/vscode/">vscode</a>
            </span>
    </div>

    
    <div class="post-content" itemprop="article text">
        <div id="post-content">
        <div>
<p>Visual Studio Code 1.21 发行版包含一个全新的 text buffer（文本缓冲区）实现，无论在速度还是在内存使用方面，该实现都更加出色。在本文中，我想讲一下我们是如何选择/设计数据结构和算法以实现这些提升的。</p>
<div class="contents topic" id="id1">
<p class="topic-title">文档目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#text-buffer" id="id19">之前的 text buffer 数据结构</a></p></li>
<li>
<p><a class="reference internal" href="#id3" id="id20">寻找新的 text buffer 实现</a></p>
<ul>
<li><p><a class="reference internal" href="#id4" id="id21">使用 piece table 来避免过多的元数据</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id22">使用缓存加速行查找</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id23">避免字符串合并陷阱</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id24">使用平衡二叉树加速行查找</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id25">减少对象分配</a></p></li>
</ul>
</li>
<li>
<p><a class="reference internal" href="#piece-tree" id="id26">Piece Tree</a></p>
<ul>
<li><p><a class="reference internal" href="#id10" id="id27">准备工作</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id28">1. 内存使用</a></p></li>
<li><p><a class="reference internal" href="#id12" id="id29">2. 文件打开时间</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id30">3. 编辑</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id31">4. 读取</a></p></li>
</ul>
</li>
<li>
<p><a class="reference internal" href="#id15" id="id32">结论与陷阱</a></p>
<ul>
<li><p><a class="reference internal" href="#id16" id="id33">得到的教训</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id34">为何不用原生代码？</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id18" id="id35">未来的工作</a></p></li>
</ul>
</div>
<!-- TEASER_END -->
<p>关于 JavaScript 程序性能的讨论，通常涉及应该使用多少原生代码来实现的问题。对于 VS Code 的 text buffer，一年多以前就有一些相关讨论。经过深入的研究，我们发现 text buffer 的 C++ 实现可以节省大量内存，但是却并没有看到所期望的性能提升。在原生代码和 V8 之间转换字符串的成本很高，在我们的案例中，这损害了使用 C++ 实现 text buffer 所获得的性能提升。我们将在本文结尾处对此进行更详细的讨论。</p>
<p>无法使用原生代码，我们必须另行寻找改善 JavaScript/TypeScript 代码的方法。我们看到一些鼓舞人心的博文，比如 <a class="reference external" href="https://mrale.ph">Vyacheslav Egorov</a> 的这篇：在 <a class="reference external" href="http://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html">文章里</a> 他演示了如何将 JavaScript 引擎推到极限，并压榨出尽可能多的性能。即便不使用底层引擎优化技巧，我们也可以通过更合适的数据结构，更快的算法来将速度提升一至多个数量级。</p>
<div class="section" id="text-buffer">
<h2><a class="toc-backref" href="#id19">之前的 text buffer 数据结构</a></h2>
<p>编辑器的思维模型是基于行的。开发者逐行读取和写入源码，编译器提供基于行/列的诊断，
堆栈跟踪包含了行号，标记引擎逐行运行，等等。尽管很简单，但从我们启动 Monaco 项目以来，支持 VS Code 的 text buffer 实现并没有太大变化。我们使用了文本行数组，效果还不错，因为一般来说文本文档相对较小。当用户键入内容时，我们在数组中找到修改的行，并将其替换。插入新行时，我们将新的行对象拼接到行数组中，JavaScript 引擎将为我们完成繁重的工作。</p>
<p>但是，我们一直收到打开某些文件会导致内存不足 VS Code 崩溃的报告。例如，有用户无法打开 <a class="reference external" href="https://github.com/Microsoft/vscode/issues/13187">35 MB 的文件</a> 。其根本原因是文件行数太多，共 1370 万行。我们需要为每行创建一个 <code class="docutils literal">ModelLine</code> 对象，每个对象占用约 40-60 字节，因此，行数组使用了大约 600 MB 的内存来存储文档。这大约是初始文件大小的 20 倍！</p>
<p>文本行数组的另一个问题是打开文件的速度。要构建行数组，我们必须按换行符拆分内容，以便从每行获得一个字符串对象。拆分过程本身会损害性能，你将在下面的基准测试中看到这种情况。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id20">寻找新的 text buffer 实现</a></h2>
<p>旧的行数组需要花费大量时间来创建，并消耗大量内存，但是它提供了快速的行查找。在理想情况下，我们应只需存储文件的文本，而无需存储其它元数据。因此，我们开始寻找较少元数据的数据结构。在审视了各种数据结构之后，我发现 <a class="reference external" href="https://en.wikipedia.org/wiki/Piece_table">piece table</a> 可能是一个不错的开始。</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id21">使用 piece table 来避免过多的元数据</a></h3>
<p>Piece table 是一种数据结构，用于表示对文本文档的一系列编辑（TypeScript 源码）：</p>
<pre class="code typescript"><a name="rest_code_97d43677d97147689f9e9fec2a00f209-1"></a><span class="kr">class</span> <span class="nx">PieceTable</span> <span class="p">{</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-2"></a>  <span class="nx">original</span>: <span class="kt">string</span><span class="p">;</span> <span class="c1">// original contents</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-3"></a>  <span class="nx">added</span>: <span class="kt">string</span><span class="p">;</span> <span class="c1">// user added contents</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-4"></a>  <span class="nx">nodes</span>: <span class="kt">Node</span><span class="p">[];</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-5"></a><span class="p">}</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-6"></a>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-7"></a><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-8"></a>  <span class="nx">type</span>: <span class="kt">NodeType</span><span class="p">;</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-9"></a>  <span class="nx">start</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-10"></a>  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-11"></a><span class="p">}</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-12"></a>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-13"></a><span class="kr">enum</span> <span class="nx">NodeType</span> <span class="p">{</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-14"></a>  <span class="nx">Original</span><span class="p">,</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-15"></a>  <span class="nx">Added</span>
<a name="rest_code_97d43677d97147689f9e9fec2a00f209-16"></a><span class="p">}</span>
</pre>
<p>当文件加载之后，piece table 的 <code class="docutils literal">original</code> 字段将包含整个文件内容， <code class="docutils literal">added</code> 字段为空，还有一个 <code class="docutils literal">NodeType.Original</code> 类型为单节点。当用户在文件末尾键入时，我们把新内容附加到 <code class="docutils literal">added</code> 字段，并在节点列表末尾插入一个新的类型节点 <code class="docutils literal">NodeType.Added</code> 。同样地，当用户在节点中间进行编辑时，我们将拆分该节点并根据需要插入一个新节点。</p>
<p>下面的动画展示了在 piece table 结构中如何逐行访问文档。它有两个 buffer 缓冲区（ <code class="docutils literal">original</code> 和 <code class="docutils literal">added</code> ），和三个节点（因为在 <code class="docutils literal">original</code> 内容中间进行了插入操作）。</p>
<div class="figure align-center">
<img alt="traditional piece table" src="../../images/traditional-piece-table.gif">
</div>
<p>Piece table 的初始内存占用接近于文档大小，修改所需的内存与编辑/添加的文本数量成正比。因此，通常来说 piece table 可以充分利用内存。然而，低内存占用的代价是访问逻辑行很慢。例如，如果要获取第 1000 行的内容，唯一的方法是从文档开头遍历每个字符，找到前 999 个换行符，然后读取每个字符直到下一个换行符。</p>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id22">使用缓存加速行查找</a></h3>
<p>传统的 piece table 节点仅包含偏移量，但是我们可以添加换行符信息以更快地查找行内容。存储换行位置的直观方法是，存储节点文本中遇到的每个换行的偏移量。</p>
<pre class="code typescript"><a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-1"></a><span class="kr">class</span> <span class="nx">PieceTable</span> <span class="p">{</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-2"></a>  <span class="nx">original</span>: <span class="kt">string</span><span class="p">;</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-3"></a>  <span class="nx">added</span>: <span class="kt">string</span><span class="p">;</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-4"></a>  <span class="nx">nodes</span>: <span class="kt">Node</span><span class="p">[];</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-5"></a><span class="p">}</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-6"></a>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-7"></a><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-8"></a>  <span class="nx">type</span>: <span class="kt">NodeType</span><span class="p">;</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-9"></a>  <span class="nx">start</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-10"></a>  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-11"></a>  <span class="nx">lineStarts</span>: <span class="kt">number</span><span class="p">[];</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-12"></a><span class="p">}</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-13"></a>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-14"></a><span class="kr">enum</span> <span class="nx">NodeType</span> <span class="p">{</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-15"></a>  <span class="nx">Original</span><span class="p">,</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-16"></a>  <span class="nx">Added</span>
<a name="rest_code_60961ebfe5544ba6ab74657b4731a3f6-17"></a><span class="p">}</span>
</pre>
<p>例如，如果想要访问指定 <code class="docutils literal">Node</code> 实例中的第二行，则可以读取 <code class="docutils literal">node.lineStarts[0]</code> 和 <code class="docutils literal">node.lineStarts[1]</code> ，这将给出该行开始和结束处的绝对偏移量。我们已经知道节点有多少个换行符，因此访问文档中随机行变得很容易：从第一个开始读取每个节点，直到找到目标换行符为止。</p>
<p>算法依旧简单，但工作的比以前更好。现在我们可以跳过整个文件块（chunks），而无需逐个字符遍历文本。稍后会看到，我们可以做得更好。</p>
</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id23">避免字符串合并陷阱</a></h3>
<p>Piece table 包含两个缓冲区（buffer），一个用于从磁盘加载的原始内容，另一个用于用户编辑。在 VS Code 中，我们使用 Node.js 的 <code class="docutils literal">fs.readFile</code> 加载文本文件，以 64 KB 的块大小（chunk）为单位交付内容。因此，当文件很大（例如 64 MB）时，我们将收到 1000 个文件块。接收到所有块后，我们把他们合并为一个大的字符串，然后将其存放到 piece table 的 <code class="docutils literal">original</code> 字段中。</p>
<p>听起来很合理对不对？直到 V8 成为了绊脚石。当尝试打开一个 500 MB 的文件我遇到了异常，因为我所使用的 V8 版本，支持的最大字符串长度为 256 MB。在将来的 V8 版本中，该限制将提高到 1 GB，但这并不能真正地解决问题。</p>
<p>与其保存 <code class="docutils literal">original</code> 和 <code class="docutils literal">added</code> 缓冲区，不如保存那一堆缓冲区（buffer）的列表。我们可以尝试让列表尽量简短，或者从 <code class="docutils literal">fs.readFile</code> 得到启发，避免任何字符串合并。每次从磁盘获取到一个 64 KB 的块，我们将其直接放到 <code class="docutils literal">buffers</code> 数组中，并创建一个指向该缓冲区的节点。</p>
<pre class="code typescript"><a name="rest_code_3205b69fdd7f47be82751167f6455985-1"></a><span class="kr">class</span> <span class="nx">PieceTable</span> <span class="p">{</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-2"></a>  <span class="nx">buffers</span>: <span class="kt">string</span><span class="p">[];</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-3"></a>  <span class="nx">nodes</span>: <span class="kt">Node</span><span class="p">[];</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-4"></a> <span class="p">}</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-5"></a>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-6"></a><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-7"></a>  <span class="nx">bufferIndex</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-8"></a>  <span class="nx">start</span>: <span class="kt">number</span><span class="p">;</span> <span class="c1">// start offset in buffers[bufferIndex]</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-9"></a>  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-10"></a>  <span class="nx">lineStarts</span>: <span class="kt">number</span><span class="p">[];</span>
<a name="rest_code_3205b69fdd7f47be82751167f6455985-11"></a><span class="p">}</span>
</pre>
</div>
<div class="section" id="id7">
<h3><a class="toc-backref" href="#id24">使用平衡二叉树加速行查找</a></h3>
<p>没有字符串合并碍手碍脚，现在我们可以打开大文件了，但这又导致了另一个潜在的性能问题。比如我们加载了一个 64 MB 的文件，piece table 将有 1000 个节点。即便在每个节点中缓存换行位置，我们仍然不清楚某个绝对行号处在哪个节点中。要获取某一行的内容，我们不得不翻遍所有节点以找到包含该行的节点。在本案例中，我们必须迭代多达 1000 个节点，具体取决于要查找的行号。因此，最糟糕的情况下，时间复杂度为 <span class="math">\(O\left(N\right)\)</span> （N 为节点数）。</p>
<p>在每个节点中缓存绝对行号，然后针对节点列表采用二分法（binary search）查找，将会加快查找速度。但是，每次修改一个节点，我们将不得不访问之后的所有节点，并对其应用行号差值。这是条不归路，但二分法查找的想法不错。要达到相同的效果，我们可以利用平衡二叉树（balanced binary tree）。</p>
<p>现在，我们必须确定使用哪些元数据作为树节点的键方便比较。如前所述，在文档中使用节点的偏移量或绝对行号，将使编辑操作的时间复杂度达到 <span class="math">\(O\left(N\right)\)</span> 。如果我们希望时间复杂度为 <span class="math">\(O\left(\log_2N\right)\)</span> ，则需要只与子树相关的东西。因此，当用户编辑文本时，我们重新计算已修改节点的元数据，然后将更改从父节点一路应用到根节点。</p>
<p>如果一个节点 <code class="docutils literal">Node</code> 只有四个属性（ <code class="docutils literal">bufferIndex</code> , <code class="docutils literal">start</code> , <code class="docutils literal">length</code>, <code class="docutils literal">lineStarts</code> ），则需要花费数秒才能找到结果。为了更快些，我们还可以存储文本长度和节点左子树的换行符数。通过这种方式，从根节点按偏移量或行号进行搜索将非常高效。存储右子树的元数据也可以，但是无需同时缓存两者。</p>
<p>现在的类如下所示：</p>
<pre class="code typescript"><a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-1"></a><span class="kr">class</span> <span class="nx">PieceTable</span> <span class="p">{</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-2"></a>  <span class="nx">buffers</span>: <span class="kt">string</span><span class="p">[];</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-3"></a>  <span class="nx">rootNode</span>: <span class="kt">Node</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-4"></a><span class="p">}</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-5"></a>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-6"></a><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-7"></a>  <span class="nx">bufferIndex</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-8"></a>  <span class="nx">start</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-9"></a>  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-10"></a>  <span class="nx">lineStarts</span>: <span class="kt">number</span><span class="p">[];</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-11"></a>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-12"></a>  <span class="nx">left_subtree_length</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-13"></a>  <span class="nx">left_subtree_lfcnt</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-14"></a>  <span class="nx">left</span>: <span class="kt">Node</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-15"></a>  <span class="nx">right</span>: <span class="kt">Node</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-16"></a>  <span class="nx">parent</span>: <span class="kt">Node</span><span class="p">;</span>
<a name="rest_code_3f67dbd9818340d3af6ae65da434e9a3-17"></a><span class="p">}</span>
</pre>
<p>在所有不同类型的平衡二叉树中，我们选择 <a class="reference external" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树</a> 是因为它更“易于编辑”。</p>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id25">减少对象分配</a></h3>
<p>假如在每个节点中存储换行偏移量，那每次更改节点时，我们可能都必须更新换行偏移量。例如，如果有一个包含 999 个换行符的节点，该 <code class="docutils literal">lineStarts</code> 数组有 1000 个元素。如果我们平均分割节点，那么将创建两个节点，每个各有一个包含约 500 个元素的数组。由于不是直接在线性内存上进行操作，因此将数组拆分为两个比仅移动指针的开销更大。</p>
<p>好消息是，piece table 中的缓冲区要么是只读的（original buffers），要么是仅追加的（changed buffers），因此缓冲区中的换行符不会变动。 <code class="docutils literal">Node</code> 仅需简单地在其对应缓冲区上保存两个对换行偏移量的引用即可。我们做的越少，性能就越好。我们的基准测试表明，这项变动使 text buffer 操作快了三倍。具体实现细节稍后再讲。</p>
<pre class="code typescript"><a name="rest_code_81f7629b25b242babc220e9f732c8087-1"></a><span class="kr">class</span> <span class="nx">Buffer</span> <span class="p">{</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-2"></a>  <span class="nx">value</span>: <span class="kt">string</span><span class="p">;</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-3"></a>  <span class="nx">lineStarts</span>: <span class="kt">number</span><span class="p">[];</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-4"></a><span class="p">}</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-5"></a>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-6"></a><span class="kr">class</span> <span class="nx">BufferPosition</span> <span class="p">{</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-7"></a>  <span class="nx">index</span>: <span class="kt">number</span><span class="p">;</span> <span class="c1">// index in Buffer.lineStarts</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-8"></a>  <span class="nx">remainder</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-9"></a><span class="p">}</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-10"></a>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-11"></a><span class="kr">class</span> <span class="nx">PieceTable</span> <span class="p">{</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-12"></a>  <span class="nx">buffers</span>: <span class="kt">Buffer</span><span class="p">[];</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-13"></a>  <span class="nx">rootNode</span>: <span class="kt">Node</span><span class="p">;</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-14"></a><span class="p">}</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-15"></a>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-16"></a><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-17"></a>  <span class="nx">bufferIndex</span>: <span class="kt">number</span><span class="p">;</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-18"></a>  <span class="nx">start</span>: <span class="kt">BufferPosition</span><span class="p">;</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-19"></a>  <span class="nx">end</span>: <span class="kt">BufferPosition</span><span class="p">;</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-20"></a>  <span class="p">...</span>
<a name="rest_code_81f7629b25b242babc220e9f732c8087-21"></a><span class="p">}</span>
</pre>
<div class="figure align-center">
<img alt="piece tree" src="../../images/piece-tree.gif">
</div>
</div>
</div>
<div class="section" id="piece-tree">
<h2><a class="toc-backref" href="#id26">Piece Tree</a></h2>
<p>我很想将这个 text buffer 实现称为“针对行模型优化的使用红黑树的多缓冲区的 piece table（Multiple buffer piece table with red-black tree, optimized for line model）”。但在我们的每日例会中，每人只有 90 秒分享他们所做的事情，多次重复这个长名字并不明智。因此，我只是简单地称为“ <strong>piece table</strong> ”，还算名符其实。</p>
<p>对这种数据结构理论上的了解是一回事，而实际性能则是另一回事。你使用的语言，代码运行的环境，客户端调用 API 的方式以及其它因素，可能会对结果有显著影响。基准测试可以提供全面的信息，因此我们针对原有的行数组实现和 piece table 实现，分别使用小/中/大型文件进行了测试。</p>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id27">准备工作</a></h3>
<p>为了结果的真实有效，我在网上找了一些现实中的文档：</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/Microsoft/TypeScript/blob/master/src/compiler/checker.ts">checker.ts</a> - 1.46 MB，26k 行</p></li>
<li><p><a class="reference external" href="https://github.com/kripken/emscripten/blob/master/tests/sqlite/sqlite3.c">sqlite.c</a> - 4.31 MB，128k 行</p></li>
<li><p><a class="reference external" href="https://github.com/titoBouzout/Dictionaries/blob/master/Russian-English%20Bilingual.dic">Russian English Bilingual dictionary</a> - 14 MB，552k 行</p></li>
</ul>
<p>并手动创建了几个大文件：</p>
<ul class="simple">
<li><p>刚打开 VS Code Insider 时的 Chromium 堆栈快照 - 54 MB，3M 行</p></li>
<li><p>checker.ts X 128 - 184 MB，3M 行</p></li>
</ul>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id28">1. 内存使用</a></h3>
<p>加载后 piece table 的内存使用非常接近原始文件大小，并且明显低于旧的实现。第一轮，piece table 获胜：</p>
<div class="figure align-center">
<img alt="memory usage" src="../../images/memoryusage.png">
</div>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id29">2. 文件打开时间</a></h3>
<p>查找并缓存换行符，比把文件拆分为字符串数组要快得多：</p>
<div class="figure align-center">
<img alt="file open" src="../../images/fileopen.png">
</div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id30">3. 编辑</a></h3>
<p>我模拟了两个工作流程：</p>
<ul class="simple">
<li><p>在文档中的随机位置进行编辑</p></li>
<li><p>按顺序键入</p></li>
</ul>
<p>我试图模仿这两种情况：对文档进行 1000 次随机编辑或 1000 次顺序插入，然后查看每个 text buffer 需要多少时间：</p>
<div class="figure align-center">
<img alt="write" src="../../images/write.png">
</div>
<p>不出所料，当文件非常小时，行数组获胜。在一个小的数组中访问随机位置，并调整约 100~150 个字符长度的字符串时，这确实非常快。但当文件包含多行（100k+）时，行数组开始阻塞。大文件中的顺序插入使这种情况变得更糟，因为 JavaScript 引擎不得不做大量工作以便调整大数组的大小。Piece table 的表现则稳定得多，因为每次编辑只不过是一次字符串附加和几个红黑树操作而已。</p>
</div>
<div class="section" id="id14">
<h3><a class="toc-backref" href="#id31">4. 读取</a></h3>
<p>对于 text buffer，调用最多的方法是 <code class="docutils literal">getLineContent</code> 。视图代码，标记引擎，链接检测，以及几乎所有依赖文档内容的组件都要调用它。某些代码，如链接检测器遍历整个文件，而其它代码，如视图代码仅按顺序读取窗口中的行。因此，我针对不同场景对该方法进行基准测试：</p>
<ul class="simple">
<li><p>进行 1000 次随机编辑，然后对所有行调用 <code class="docutils literal">getLineContent</code></p></li>
<li><p>进行 1000 次顺序插入，然后对所有行调用 <code class="docutils literal">getLineContent</code></p></li>
<li><p>进行 1000 次随机编辑，然后读取 10 个不同窗口内的行</p></li>
<li><p>进行 1000 次顺序插入，然后读取 10 个不同窗口内的行</p></li>
</ul>
<div class="figure align-center">
<img alt="read" src="../../images/read.png">
</div>
<p>TA DA，我们找到了 piece tree 的阿喀琉斯之踵。一个大文件，经过 1000 次编辑，将会有成千上万个节点。即便查找一行的复杂度为 <span class="math">\(O\left(\log_2N\right)\)</span> （ <code class="docutils literal">N</code> 为节点数），也明显超过了行数组的 <span class="math">\(O\left(1\right)\)</span> 。</p>
<p>进行上千次编辑是比较罕见的。在大文件中替换一个常用子字符串，你可能会见到这一场景。另外，我们正在谈论的是每个 <code class="docutils literal">getLineContent</code> 调用所花费的时间，因此目前暂时不关心它。大多数 <code class="docutils literal">getLineContent</code> 调用来自视图渲染和标记，行内容的后期处理也非常耗时。DOM 构建以及视窗的渲染/标记通常需要花费数十毫秒，其中 <code class="docutils literal">getLineContent</code> 仅占不到 1%。无论怎样，我们总是可以考虑实现一个正常化步骤，如果满足某些条件（例如，节点数量很多），我们将重新创建缓冲区和节点。</p>
</div>
</div>
<div class="section" id="id15">
<h2><a class="toc-backref" href="#id32">结论与陷阱</a></h2>
<p>在大多数情况下，除了基于行的查找之外，piece tree 的性能都优于行数组。</p>
<div class="section" id="id16">
<h3><a class="toc-backref" href="#id33">得到的教训</a></h3>
<ul class="simple">
<li><p>这次实现教给我最重要的一课是， <strong>始终进行真实世界的分析</strong> 。每一次我都发现，对哪些方法调用最多的假设与现实不符。例如，当我开始实现 piece tree 时，我把重点放在优化三个原子操作： <code class="docutils literal">insert</code> ， <code class="docutils literal">delete</code> ， <code class="docutils literal">search</code> 上。但是，当我将其集成到 VS Code 中时，那些都不重要。调用最多的方法是 <code class="docutils literal">getLineContent</code> 。</p></li>
<li><p><strong>处理</strong> <code class="docutils literal">CRLF</code> <strong>或者混合换行符是程序员的噩梦</strong> 。对于每次修改，我们都要检查它是否分割了回车/换行（CRLF）序列，或者是否创建了新的 CRLF 序列。在树节点中处理所有可能的情况，进行几次尝试，直到找到正确快速的解决方案。</p></li>
<li><p><strong>GC（垃圾回收）可以轻易消耗你的 CPU 时间</strong> 。我们的文本模型曾假定缓冲区存储在数组中，我们频繁使用 <code class="docutils literal">getLineContent</code> ，尽管有时不是必需的。例如，如果只想知道某一行第一个字符的字符代码，我们先使用 <code class="docutils literal">getLineContent</code> ，然后执行 <code class="docutils literal">charCodeAt</code> 。使用 piece table 时， <code class="docutils literal">getLineContent</code> 将创建一个子字符串，检查过字符代码后那一行的子字符串被立即丢弃。这很浪费，我们正在努力采用更合适的方法。</p></li>
</ul>
</div>
<div class="section" id="id17">
<h3><a class="toc-backref" href="#id34">为何不用原生代码？</a></h3>
<p>文章开头我曾说过会回到这个问题。</p>
<p><strong>太长不看：</strong> 我们尝试过，对我们来说没有用。</p>
<p>我们使用 C++ 实现了 text buffer，并使用原生 node 模块绑定将其集成到 VS Code 中。Text buffer 是 VS Code 中的常用组件，许多调用都是针对 text buffer 进行的。当调用和实现两者都使用 JavaScript 编写时，V8 可以内联许多此类调用。使用原生 text buffer 后，JavaScript &lt;=&gt; C++ 之间需要来回转换，考虑到来回转换的次数，这会把一切都减慢下来。</p>
<p>例如，VS Code 的 <strong>切换行注释</strong> 命令是通过遍历所有选定的行并逐一分析来实现的。该逻辑是用 JavaScript 编写的，针对每一行都会调用 <code class="docutils literal">TextBuffer.getLineContent</code> 方法。而每一次调用，最终都得越过 C++/JavaScript 边界，并且必须返回一个 JavaScript <code class="docutils literal">string</code> 对象，因为我们的所有代码均基于 JavaScript 构建的 API。</p>
<p>我们的选择很有限。在 C++ 中，我们要么针对每一次 <code class="docutils literal">getLineContent</code> 调用都分配一个新的 JavaScript <code class="docutils literal">string</code> 对象，这意味着把字符串拷贝来拷贝去，要么利用 V8 的 <code class="docutils literal">SlicedString</code> 或者 <code class="docutils literal">ConstString</code> 类型。然而，只有当底层存储也使用 V8 字符串时，才可以使用 V8 的字符串类型。但不幸的是，V8 的字符串并不是多线程安全的。</p>
<p>我们可以尝试通过更改 TextBuffer API 来克服这一点，或者将更多代码移植到 C++ 来避免 JavaScript/C++ 边界成本。但是，我们意识到我们同时在做两件事：我们使用不同于行数组的数据结构在重写 text buffer，同时还使用了 C++ 来编写而不是 JavaScript。因此，我们决定将 text buffer 的实现寄托于 JavaScript，而不是花半年的时间在我们不知道是否会得到回报的东西上，同时我们只改变数据结构和相关算法。我们认为，这是正确的决定。</p>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id35">未来的工作</a></h2>
<p>我们仍然有一些使用场景需要优化。例如， <strong>查找</strong> 命令当前是逐行运行，但这是不对的。当仅需要一个子字符串时，我们应该避免对 <code class="docutils literal">getLineContent</code> 不必要的调用。我们将逐步改进并释出这些优化。即使没有这些优化，新的 text buffer 实现也可以提供比以前更好的用户体验，它现在已经是最新稳定版 VS Code 的默认配置。</p>
<p>编码愉快！</p>
<p>Peng Lyu, VS Code 团队成员 <a class="reference external" href="https://twitter.com/njukidreborn">@njukidreborn</a></p>
</div>
</div>
        </div>
    </div>
    <div class="post-info">
        <p>引用资源：<a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation" target="_blank">https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation</a></p>
        <p>文章链接：<a href="https://macplay.github.io/posts/text-buffer-reimplementation/" target="_blank">https://macplay.github.io/posts/text-buffer-reimplementation/</a></p>
        <p>发布/更新于：
            <time datetime="2019-10-25 13:16:43 UTC+08:00">
            2019-10-25 13:16
            </time></p>
        <p>版权声明：如无特别说明，本站文章均遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">CC BY-NC-SA 4.0</a> 协议，转载请注明作者及出处。</p>
    </div>
        <div class="post-navigation no-print">
        <div class="ui huge secondary stackable menu">
            <a class="post-nav-item post-nav-previous item" href="../atoms-new-concurrency-friendly-buffer-implementation/" title="Previous post"><i class="angle double left icon"></i> 【译】Atom 新的并发友好型 buffer 实现</a>
        <div class="right menu">
            <a class="post-nav-item post-nav-next item" href="../run-vim-editor-on-browsers/" title="Next post">在浏览器中运行 Vim 编辑器 <i class="angle double right icon"></i></a>
        </div>
        </div>
    </div>

        <div id="gitalk-container" class="comments-block no-print"></div>
</div>
                    </div>
                </main><div class="footer extra-block no-print">
    <span class="footer_item">
        <a href="../../pages/you-qing-lian-jie/">友情链接</a>
    </span>
    <span class="footer_item">
        <a href="../../pages/liu-yan-ban/">留言板</a>
    </span>
    <span class="footer_item">
        <a href="../../pages/ge-ren-dong-tai/">碎碎念</a>
    </span>
    </div>
            <div class="footer social-link no-print">
            <a href="https://github.com/ashfinal" target="_blank"><i class="grey large github icon"></i></a>
            <a href="http://weibo.com/ashfinal/" target="_blank"><i class="grey large weibo icon"></i></a>
            <a href="mailto://ashfinal@sina.cn" target="_blank"><i class="grey large mail icon"></i></a>
            </div>
        <div class="ui basic center aligned segment no-print">Contents © 2020         <a href="mailto:ashfinal@sina.cn">ashfinal</a> - Powered by         <a href="https://getnikola.com" target="_blank" rel="nofollow">Nikola</a>         </div>

            </div>
            <div class="computer only three wide column no-print">
                <div id="right-side">
                </div>
            </div>
        </div>

        <!-- GoStats JavaScript Based Code -->
        <script type="text/javascript">(function(c,o,m,p,u,t,e){
        c['GoStatsObject']=u;c[u]=c[u]||function(){(c[u].q=c[u].q||[]).push(arguments)},
        c[u].l=1*new Date();t=o.createElement(m);t.async=1;t.src=p;
        e=o.getElementsByTagName(m)[0];e.parentNode.insertBefore(t,e);
        })(window,document,'script','//www.gostats.org/5.js','go');
        go('init',100479892,{'img_counter_type':5,'img_image_type':1});go('send');</script><!-- End GoStats JavaScript Based Code --><script type="text/javascript" src="../../assets/js/jquery-3.3.1.min.js"></script><script type="text/javascript" src="../../assets/js/semantic.min.js"></script><script type="text/javascript" src="../../assets/js/jquery.fancybox.min.js"></script><script type="text/javascript" src="../../assets/js/cookie.min.js"></script><script>
            $(document).ready(function(){
                $(".ui.dropdown").dropdown();
                $('.ui.accordion').accordion();
                var newstr = $('.cookie.nag').text();
                $('.cookie.nag').nag({
                    key: 'globalnotice',
                    value: newstr
                  });
                $('.image-reference').fancybox();
            });
        </script><script src="../../assets/js/katex.min.js"></script><script src="../../assets/js/auto-render.min.js"></script><script>
                renderMathInElement(document.body,
                    {
                        delimiters: [
                            {left: "$$", right: "$$", display: true},
                            {left: "\\[", right: "\\]", display: true},
                            {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
                            {left: "\\(", right: "\\)", display: false}
                        ]
                    }
                );
            </script><script src="../../assets/js/md5.min.js"></script><script src="../../assets/js/gitalk.min.js"></script><script>
        const gitalk = new Gitalk({
            clientID: '12fcda845097d895a24c',
            clientSecret: '50ed60cde5f40897205197b4265b474cefbedc49',
            repo: 'macplay.github.io',
            owner: 'macplay',
            admin: ['macplay', 'ashfinal'],
            id: md5(window.location.pathname),
            // facebook-like distraction free mode
            distractionFreeMode: false
        })
        gitalk.render('gitalk-container')
    </script>
</body>
</html>
