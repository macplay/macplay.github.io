<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MacPlay</title><link>https://macplay.github.io/</link><description>Share something interesting about byte ocean</description><atom:link href="https://macplay.github.io/en/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:ashfinal@sina.cn"&gt;ashfinal&lt;/a&gt; </copyright><lastBuildDate>Wed, 26 Aug 2020 08:50:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>FFmpeg Filtering Guide</title><link>https://macplay.github.io/en/posts/ffmpeg-filtering-guide/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/ffmpeg_datascope.png"&gt;&lt;img alt="ffmpeg_datascope" src="https://macplay.github.io/images/ffmpeg_datascope.thumbnail.png"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title"&gt;文档目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/#ffmpeg-filtering" id="id12"&gt;FFmpeg Filtering 介绍&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/#testsrc" id="id13"&gt;testsrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/#ffmpeg-ffplay-filters" id="id14"&gt;在 ffmpeg/ffplay 中使用 filters&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/#mpv-player" id="id15"&gt;mpv player&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/#mmate" id="id16"&gt;mmate&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="ffmpeg-filtering"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/#id12"&gt;FFmpeg Filtering 介绍&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Filtering in FFmpeg is enabled through the libavfilter library.&lt;/p&gt;
&lt;p&gt;In libavfilter, a filter can have multiple inputs and multiple outputs. To illustrate the sorts of things that are possible, we consider the following filtergraph:&lt;/p&gt;
&lt;pre class="literal-block"&gt;                [main]
input --&amp;gt; split ---------------------&amp;gt; overlay --&amp;gt; output
            |                             ^
            |[tmp]                  [flip]|
            +-----&amp;gt; crop --&amp;gt; vflip -------+&lt;/pre&gt;
&lt;p&gt;This filtergraph splits the input stream in two streams, then sends one stream through the crop filter and the vflip filter, before merging it back with the other stream by overlaying it on top. You can use the following command to achieve this:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/ffmpeg-filtering-guide/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><guid>https://macplay.github.io/en/posts/ffmpeg-filtering-guide/</guid><pubDate>Mon, 24 Feb 2020 12:50:03 GMT</pubDate></item><item><title>The power of diff</title><link>https://macplay.github.io/en/posts/the-power-of-diff/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;Lots of people use vimdiff to understand and handle diffs in console mode. While there exist more specialized tools for comparing files, vimdiff has always worked well enough for me.&lt;/p&gt;
&lt;div class="section" id="the-inefficiency-of-the-external-diff"&gt;
&lt;h2&gt;The inefficiency of the external diff&lt;/h2&gt;
&lt;p&gt;However, Vim’s diff mode was seriously lacking. This was basically because it needed to write down temporary files, shell out and run a manual diff command and parse the result back and as one can imagine, this could be slow and was seriously inefficient.&lt;/p&gt;
&lt;p&gt;Additionally, this required to have a diff binary available that was able to create &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Diff#Edit_script"&gt;ed like style diff&lt;/a&gt;, so one could not even fall-back to using git-diff (which is considered to have one of the best tested diff libraries and allows to select different algorithms) for creating those diffs. This lead to the creation of vimscript &lt;a class="reference external" href="https://github.com/chrisbra/vim-diff-enhanced"&gt;plugins&lt;/a&gt;, that would internally translate a unified diff back into an ed-like diff. Of course this would add an extra performance penalty.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/the-power-of-diff/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>asciinema</category><category>diff</category><category>vim</category><guid>https://macplay.github.io/en/posts/the-power-of-diff/</guid><pubDate>Thu, 14 Nov 2019 14:28:48 GMT</pubDate></item><item><title>【译】Atom 新的并发友好型 buffer 实现</title><link>https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;Atom 的一些功能依赖于缓冲区（buffer）内容基础上的运算（可能会花费很长时间），但是直到最近，还只能从运行在主线程上的 JavaScript 访问缓冲区的文本。这使得无法在所有情况下保证 Atom 的响应能力，尤其是在编辑较大文件时。&lt;/p&gt;
&lt;p&gt;这种情况随着 Atom 1.19 的发布而有所改变，该版本通过使用 C++ 实现的文本存储极大地提高了并行处理能力。这项新设计为性能和可伸缩性提供了诸多好处，其中主要优点之一是 worker 线程可以读取之前缓冲区的快照（snapshot），而不会阻塞主线程上的写入。在这篇文章中，我们将深入介绍 Atom 的文本存储新方法，然后探讨由此带来的首批优化。&lt;/p&gt;
&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title"&gt;文档目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#layering" id="id12"&gt;分层（layering）的变动&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#patch" id="id13"&gt;Patch 的数据结构&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id2" id="id14"&gt;存在的问题&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id3" id="id15"&gt;原生的解决方案&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#splay-trees" id="id16"&gt;Splay trees&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id4" id="id17"&gt;为我们的用例增强 splay tree&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id6" id="id18"&gt;一些初始优化&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#unsaved-changes" id="id19"&gt;高效备份 unsaved changes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id8" id="id20"&gt;异步保存&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id9" id="id21"&gt;自动补全时在后台进行子序列匹配&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/#id11" id="id22"&gt;未来回报&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://macplay.github.io/en/posts/atoms-new-concurrency-friendly-buffer-implementation/</guid><pubDate>Sat, 26 Oct 2019 06:41:03 GMT</pubDate></item><item><title>【译】重新实现 Text Buffer</title><link>https://macplay.github.io/en/posts/text-buffer-reimplementation/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;Visual Studio Code 1.21 发行版包含一个全新的 text buffer（文本缓冲区）实现，无论在速度还是在内存使用方面，该实现都更加出色。在本文中，我想讲一下我们是如何选择/设计数据结构和算法以实现这些提升的。&lt;/p&gt;
&lt;div class="contents topic" id="id1"&gt;
&lt;p class="topic-title"&gt;文档目录&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#text-buffer" id="id19"&gt;之前的 text buffer 数据结构&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id3" id="id20"&gt;寻找新的 text buffer 实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id4" id="id21"&gt;使用 piece table 来避免过多的元数据&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id5" id="id22"&gt;使用缓存加速行查找&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id6" id="id23"&gt;避免字符串合并陷阱&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id7" id="id24"&gt;使用平衡二叉树加速行查找&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id9" id="id25"&gt;减少对象分配&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#piece-tree" id="id26"&gt;Piece Tree&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id10" id="id27"&gt;准备工作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id11" id="id28"&gt;1. 内存使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id12" id="id29"&gt;2. 文件打开时间&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id13" id="id30"&gt;3. 编辑&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id14" id="id31"&gt;4. 读取&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id15" id="id32"&gt;结论与陷阱&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id16" id="id33"&gt;得到的教训&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id17" id="id34"&gt;为何不用原生代码？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://macplay.github.io/en/posts/text-buffer-reimplementation/#id18" id="id35"&gt;未来的工作&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/text-buffer-reimplementation/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://macplay.github.io/en/posts/text-buffer-reimplementation/</guid><pubDate>Thu, 24 Oct 2019 09:35:29 GMT</pubDate></item><item><title>在浏览器中运行 Vim 编辑器</title><link>https://macplay.github.io/en/posts/run-vim-editor-on-browsers/</link><dc:creator>ashfinal</dc:creator><description>&lt;figure&gt;&lt;img src="https://macplay.github.io/images/chrome_vim_wasm.thumbnail.png"&gt;&lt;/figure&gt; &lt;div&gt;&lt;p&gt;有人将 Vim 编辑器移植到了 WebAssembly (Wasm) 格式： &lt;a class="reference external" href="https://github.com/rhysd/vim.wasm"&gt;vim.wasm: Vim Ported to WebAssembly&lt;/a&gt; 。 &lt;a class="reference external" href="https://webassembly.org/"&gt;Wasm&lt;/a&gt; 是一种底层的二进制指令格式，理论上能实现接近 C/C++/Rust 等编译性语言的执行速度，目前已经在主流浏览器 Chrome/Safari/Firefox/Edge 中得到支持。所以现在，你可以在浏览器上体验原汁原味的 Vim 了！&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="vim.wasm on chrome" src="https://macplay.github.io/images/chrome_vim_wasm.png"&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/run-vim-editor-on-browsers/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://macplay.github.io/en/posts/run-vim-editor-on-browsers/</guid><pubDate>Wed, 23 Oct 2019 13:29:00 GMT</pubDate></item><item><title>Vim Cheatsheet</title><link>https://macplay.github.io/en/posts/vim-cheatsheet-2/</link><dc:creator>ashfinal</dc:creator><description>&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/vim_cheatsheet.png"&gt;&lt;img alt="vim cheatsheet" src="https://macplay.github.io/images/vim_cheatsheet.thumbnail.png"&gt;&lt;/a&gt;
&lt;p class="caption"&gt;&lt;em&gt;via&lt;/em&gt; &lt;a class="reference external" href="https://github.com/mhinz/vim-galore"&gt;vim-galore&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description><guid>https://macplay.github.io/en/posts/vim-cheatsheet-2/</guid><pubDate>Sat, 19 Oct 2019 10:48:45 GMT</pubDate></item><item><title>Writing a plugin that loads quickly</title><link>https://macplay.github.io/en/posts/writing-a-plugin-that-loads-quickly/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/lazy_loading.jpg"&gt;&lt;img alt="lazy loading" src="https://macplay.github.io/images/lazy_loading.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;A plugin may grow and become quite long. The startup delay may become noticeable, while you hardly ever use the plugin. Then it's time for a quickload plugin.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/writing-a-plugin-that-loads-quickly/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>plugin</category><category>vim</category><guid>https://macplay.github.io/en/posts/writing-a-plugin-that-loads-quickly/</guid><pubDate>Fri, 18 Oct 2019 06:11:04 GMT</pubDate></item><item><title>Improve and Extend Your Text Objects With targets.vim</title><link>https://macplay.github.io/en/posts/improve-and-extend-your-text-objects-with-targetsvim/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;p&gt;Welcome back to the &lt;a class="reference external" href="https://www.barbarianmeetscoding.com/blog/categories/exploring-vim-plugins"&gt;Exploring Vim Plugins series&lt;/a&gt; ! In this series you learn how to become a little bit more productive each day by discovering awesome Vim plugins and how to master them. And today, it’s time for one of my favorites: &lt;a class="reference external" href="https://github.com/wellle/targets.vim"&gt;targets.vim&lt;/a&gt; .&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="become 1 percent better" src="https://macplay.github.io/images/become-1-percent-better.jpg"&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/improve-and-extend-your-text-objects-with-targetsvim/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>translation</category><category>vim</category><guid>https://macplay.github.io/en/posts/improve-and-extend-your-text-objects-with-targetsvim/</guid><pubDate>Fri, 11 Oct 2019 09:05:40 GMT</pubDate></item><item><title>What is your most productive shortcut with Vim?</title><link>https://macplay.github.io/en/posts/what-is-your-most-productive-shortcut-with-vim/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://macplay.github.io/images/vim-keyboard-cover-macbook.jpg"&gt;&lt;img alt="/images/vim-keyboard-cover-macbook.thumbnail.jpg" src="https://macplay.github.io/images/vim-keyboard-cover-macbook.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;I've heard a lot about &lt;a class="reference external" href="http://www.vim.org"&gt;Vim&lt;/a&gt; , both pros and cons. It really seems you should be (as a developer) faster with Vim than with any other editor. I'm using Vim to do some basic stuff and I'm at best 10 times less productive with Vim.&lt;/p&gt;
&lt;p&gt;The only two things you should care about when you talk about speed (you may not care enough about them, but you should) are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;Using alternatively left and right hands is the &lt;strong&gt;fastest&lt;/strong&gt; way to use the keyboard.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Never touching the mouse is the second way to be as fast as possible. It takes ages for you to move your hand, grab the mouse, move it, and bring it back to the keyboard (and you often have to look at the keyboard to be sure you returned your hand properly to the right place)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here are two examples demonstrating why I'm far less productive with Vim.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/what-is-your-most-productive-shortcut-with-vim/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>linux</category><category>vim</category><guid>https://macplay.github.io/en/posts/what-is-your-most-productive-shortcut-with-vim/</guid><pubDate>Sun, 29 Sep 2019 00:50:23 GMT</pubDate></item><item><title>Oni 0.32 版本释出</title><link>https://macplay.github.io/en/posts/oni-032-ban-ben-shi-chu/</link><dc:creator>ashfinal</dc:creator><description>&lt;div&gt;&lt;!-- vim:set et sw=4 ts=4 ft=rst: --&gt;
&lt;!-- This file interpreters the title of URL in links.ref --&gt;
&lt;!-- vim:set et sw=4 ts=4 ft=rst: --&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="/images/oni_release.png" src="https://macplay.github.io/images/oni_release.png"&gt;
&lt;/div&gt;
&lt;div class="admonition attention"&gt;
&lt;p class="admonition-title"&gt;注意&lt;/p&gt;
&lt;p&gt;Since they've moved to oni2, that changed lots of things, I'm gonna flag this post as obsolete. DON'T READ!&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;本来对这次版本更新还有些不以为然：为何不把精力放在完善 &lt;a class="reference external" href="https://langserver.org/"&gt;Language Server Protocol&lt;/a&gt; 支持，而跑去写什么新手教程呢？直到今天尝试了下教程，又看了文字版更新内容，才明白过来：Oni 编辑器正朝着我期待的方向前进！&lt;/p&gt;
&lt;p&gt;来看看本次更新的两个重要功能：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://macplay.github.io/en/posts/oni-032-ban-ben-shi-chu/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://macplay.github.io/en/posts/oni-032-ban-ben-shi-chu/</guid><pubDate>Sat, 14 Apr 2018 14:55:50 GMT</pubDate></item></channel></rss>